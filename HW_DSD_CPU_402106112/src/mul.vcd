$date
	Mon Jul 07 11:14:44 2025
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module mul_16_tb $end
$var wire 16 ! result [15:0] $end
$var wire 16 " exp [15:0] $end
$var reg 16 # A [15:0] $end
$var reg 16 $ B [15:0] $end
$scope module mul $end
$var wire 16 % A [15:0] $end
$var wire 16 & B [15:0] $end
$var wire 16 ' z3 [15:0] $end
$var wire 16 ( z2 [15:0] $end
$var wire 16 ) z1 [15:0] $end
$var wire 16 * z0 [15:0] $end
$var wire 16 + result [15:0] $end
$var wire 8 , B_L [7:0] $end
$var wire 8 - B_H [7:0] $end
$var wire 8 . A_L [7:0] $end
$var wire 8 / A_H [7:0] $end
$scope module mul1 $end
$var wire 8 0 A [7:0] $end
$var wire 8 1 B [7:0] $end
$var wire 16 2 result [15:0] $end
$var reg 16 3 A_shift [15:0] $end
$var reg 8 4 B_shift [7:0] $end
$var reg 16 5 product [15:0] $end
$var integer 32 6 i [31:0] $end
$upscope $end
$scope module mul2 $end
$var wire 8 7 A [7:0] $end
$var wire 8 8 B [7:0] $end
$var wire 16 9 result [15:0] $end
$var reg 16 : A_shift [15:0] $end
$var reg 8 ; B_shift [7:0] $end
$var reg 16 < product [15:0] $end
$var integer 32 = i [31:0] $end
$upscope $end
$scope module mul3 $end
$var wire 8 > A [7:0] $end
$var wire 8 ? B [7:0] $end
$var wire 16 @ result [15:0] $end
$var reg 16 A A_shift [15:0] $end
$var reg 8 B B_shift [7:0] $end
$var reg 16 C product [15:0] $end
$var integer 32 D i [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
$comment Show the parameter values. $end
$dumpall
$end
#0
$dumpvars
b1000 D
b11011010 C
b0 B
b100000000 A
b11011010 @
b11011010 ?
b1 >
b1000 =
b0 <
b0 ;
b0 :
b0 9
b10000000 8
b0 7
b1000 6
b1011010 5
b0 4
b100000000 3
b1011010 2
b1011010 1
b1 0
b0 /
b1 .
b10000000 -
b1011010 ,
b1000000001011010 +
b1011010 *
b10000000 )
b0 (
b11011010 '
b1000000001011010 &
b1 %
b1000000001011010 $
b1 #
b1000000001011010 "
b1000000001011010 !
$end
#10
b1000 =
b1111111100000000 :
b1000 D
b0 B
b1111000000000000 A
b111011100010000 '
b111011100010000 @
b111011100010000 C
b1000 6
b0 4
b1111000100000000 3
b1111100010001111 !
b1111100010001111 +
b1111111110000001 )
b111011110001111 *
b111011110001111 2
b111011110001111 5
b0 -
b0 8
b1111111 ?
b1111111 ,
b1111111 1
b11111111 /
b11111111 7
b11110000 >
b11110001 .
b11110001 0
b1111111 $
b1111111 &
b1111100010001111 "
b1111111111110001 #
b1111111111110001 %
#20
b1000 =
b0 ;
b0 :
b1000 D
b0 B
b110010000000000 A
b110000110101000 '
b110000110101000 @
b110000110101000 C
b1000 6
b0 4
b110010000000000 3
b1111111000001100 !
b1111111000001100 +
b1111111110011100 )
b110001000001100 *
b110001000001100 2
b110001000001100 5
b11111111 -
b11111111 8
b11111010 ?
b11111011 ,
b11111011 1
b0 /
b0 7
b1100100 >
b1100100 .
b1100100 0
b1111111111111011 $
b1111111111111011 &
b1111111000001100 "
b1100100 #
b1100100 %
#30
b1111111000000001 (
b1111111000000001 9
b1111111000000001 <
b1000 =
b0 ;
b1111111100000000 :
b1000 D
b0 B
b1110011000000000 A
b1110000110000010 '
b1110000110000010 @
b1110000110000010 C
b1000 6
b0 4
b1110011100000000 3
b1100100 !
b1100100 +
b11101 )
b1110001101100100 *
b1110001101100100 2
b1110001101100100 5
b11111011 ?
b11111100 ,
b11111100 1
b11111111 /
b11111111 7
b11100110 >
b11100111 .
b11100111 0
b1111111111111100 $
b1111111111111100 &
b1100100 "
b1111111111100111 #
b1111111111100111 %
#40
b1000 =
b0 ;
b0 :
b0 (
b0 9
b0 <
b1000 D
b0 B
b0 A
b0 '
b0 @
b0 C
b1000 6
b0 4
b0 3
b0 !
b0 +
b0 )
b0 *
b0 2
b0 5
b100 -
b100 8
b11010110 ?
b11010010 ,
b11010010 1
b0 /
b0 7
b0 >
b0 .
b0 0
b10011010010 $
b10011010010 &
b0 "
b0 #
b0 %
#50
b1000 =
b111111100000000 :
b11111100 '
b11111100 @
b11111100 C
b1000 D
b0 B
b111111000000000 A
b1111111111111110 !
b1111111111111110 +
b1111111011111110 )
b111111110 *
b111111110 2
b111111110 5
b1000 6
b0 4
b1111111100000000 3
b0 -
b0 8
b10 ?
b10 ,
b10 1
b1111111 /
b1111111 7
b1111110 >
b11111111 .
b11111111 0
b10 $
b10 &
b1111111111111110 "
b111111111111111 #
b111111111111111 %
#60
